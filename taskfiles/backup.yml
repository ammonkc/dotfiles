# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: 3

vars:
  # XDG Base Directory for backups
  BACKUP_BASE: '${XDG_DATA_HOME:-$HOME/.local/share}/dotfiles/backups'
  BACKUP_DIR:
    sh: echo "{{.BACKUP_BASE}}/$(date +%Y%m%d-%H%M%S)"
  # Get list of all backup timestamps (sorted newest first)
  BACKUP_TIMESTAMPS:
    sh: find "{{.BACKUP_BASE}}" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | xargs -n1 basename 2>/dev/null | sort -r || true

tasks:
  # ============================================================================
  # Primary Tasks
  # ============================================================================

  list:
    desc: List all available backups
    aliases: [ls]
    vars:
      HAS_BACKUPS:
        sh: test -d "{{.BACKUP_BASE}}" && echo "true" || echo "false"
    preconditions:
      - sh: test "{{.HAS_BACKUPS}}" = "true"
        msg: "â„¹ï¸  No backups found"
    cmds:
      - echo "ðŸ“¦ Available backups in {{.BACKUP_BASE}}:"
      - echo ""
      - for:
          var: BACKUP_TIMESTAMPS
          as: TIMESTAMP
        task: list:details
        vars:
          TIMESTAMP: '{{.TIMESTAMP}}'

  restore:
    desc: Restore files from a backup
    summary: |
      Restore backed up files from a specific timestamp
      Usage: task backup:restore TIMESTAMP=20240325-143022

      Warning: This will overwrite current files!
    vars:
      TIMESTAMP: '{{.TIMESTAMP | default ""}}'
      BACKUP_PATH: '{{.BACKUP_BASE}}/{{.TIMESTAMP}}'
      # Get packages to restore
      RESTORE_PACKAGES:
        sh: find "{{.BACKUP_BASE}}/{{.TIMESTAMP}}" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | sort || true
    preconditions:
      - sh: test -n "{{.TIMESTAMP}}"
        msg: "TIMESTAMP variable is required. Usage: task backup:restore TIMESTAMP=20240325-143022"
      - sh: test -d "{{.BACKUP_PATH}}"
        msg: "Backup '{{.TIMESTAMP}}' not found. Use 'task backup:list' to see available backups"
    cmds:
      - echo "ðŸ”„ Restoring backup from {{.TIMESTAMP}}..."
      - echo ""
      - for:
          var: RESTORE_PACKAGES
          as: PACKAGE
        task: restore:package
        vars:
          TIMESTAMP: '{{.TIMESTAMP}}'
          PACKAGE: '{{.PACKAGE}}'
      - echo ""
      - echo "âœ“ Backup restored successfully"
      - echo "âš ï¸  You may want to unstow packages first to avoid conflicts"

  clean:
    desc: Remove old backups
    summary: |
      Remove old backups, keeping only the most recent N
      Usage: task backup:clean KEEP=5
    vars:
      KEEP: '{{.KEEP | default "5"}}'
      # Get list of old backups to remove (all except the most recent KEEP)
      OLD_BACKUPS:
        sh: find "{{.BACKUP_BASE}}" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | xargs -n1 basename 2>/dev/null | sort -r | tail -n +$(({{.KEEP}} + 1)) || true
    preconditions:
      - sh: test -d "{{.BACKUP_BASE}}"
        msg: "â„¹ï¸  No backups found"
    status:
      # Skip if no old backups to remove
      - test -z "{{.OLD_BACKUPS}}"
    cmds:
      - echo "ðŸ—‘ï¸  Cleaning old backups (keeping {{.KEEP}} most recent)..."
      - for:
          var: OLD_BACKUPS
          as: BACKUP_DIR
        task: clean:old_backup
        vars:
          BACKUP_DIR: '{{.BACKUP_DIR}}'
      - echo "âœ“ Cleanup complete"

  clean:empty:
    desc: Remove empty backup directories
    summary: |
      Removes backup directories that contain no files
      Useful for cleaning up after idempotent runs
    vars:
      # Get list of empty backup directories
      EMPTY_BACKUPS:
        sh: find "{{.BACKUP_BASE}}" -mindepth 1 -maxdepth 1 -type d -empty 2>/dev/null | xargs -n1 basename 2>/dev/null || true
    preconditions:
      - sh: test -d "{{.BACKUP_BASE}}"
        msg: "â„¹ï¸  No backups found"
    status:
      # Skip if no empty directories found
      - test -z "{{.EMPTY_BACKUPS}}"
    cmds:
      - echo "ðŸ—‘ï¸  Removing empty backup directories..."
      - for:
          var: EMPTY_BACKUPS
          as: BACKUP_DIR
        task: clean:empty_backup
        vars:
          BACKUP_DIR: '{{.BACKUP_DIR}}'
      - echo "âœ“ Removed empty backup directories"

  # ============================================================================
  # Internal Tasks - Backup Operations
  # ============================================================================

  backup_conflicts:
    desc: Detect and backup files that conflict with stow operation
    internal: true
    vars:
      PACKAGE: '{{.PACKAGE}}'
      PACKAGES_DIR: '{{.PACKAGES_DIR}}'
      STOW_FLAGS: '{{.STOW_FLAGS}}'
      # Get list of conflicting files by simulating stow
      CONFLICTS:
        sh: cd {{.PACKAGES_DIR}} && stow -n {{.STOW_FLAGS}} -t $HOME "{{.PACKAGE}}" 2>&1 | grep "existing target is" | awk '{print $NF}' | tr -d "'" || true
    dir: '{{.PACKAGES_DIR}}'
    status:
      # Skip entirely if no conflicts found
      - test -z "{{.CONFLICTS}}"
    cmds:
      - task: check_conflicts
        vars:
          PACKAGE: '{{.PACKAGE}}'
          CONFLICTS: '{{.CONFLICTS}}'
      - for:
          var: CONFLICTS
          split: '\n'
        task: backup_file
        vars:
          FILE_PATH: '{{.ITEM}}'
          PACKAGE: '{{.PACKAGE}}'

  backup_file:
    desc: Backup a single file to the backup directory
    internal: true
    silent: true
    vars:
      FILE_PATH: '{{.FILE_PATH}}'
      PACKAGE: '{{.PACKAGE}}'
      SOURCE: '$HOME/{{.FILE_PATH}}'
      DEST_DIR: '{{.BACKUP_DIR}}/{{.PACKAGE}}'
    status:
      # Skip if it's a symlink (already managed by stow)
      - test -L "$HOME/{{.FILE_PATH}}"
      # Skip if file doesn't exist
      - test ! -e "$HOME/{{.FILE_PATH}}"
    cmds:
      - mkdir -p "{{.DEST_DIR}}/$(dirname '{{.FILE_PATH}}')"
      - echo "      Backing up:" "$HOME/{{.FILE_PATH}}"
      - cp -a "$HOME/{{.FILE_PATH}}" "{{.DEST_DIR}}/{{.FILE_PATH}}"
      - rm -rf "$HOME/{{.FILE_PATH}}"

  check_conflicts:
    desc: Check for stow conflicts and warn if found
    internal: true
    silent: true
    vars:
      PACKAGE: '{{.PACKAGE}}'
      CONFLICTS: '{{.CONFLICTS}}'
    preconditions:
      - sh: 'test -z "{{.CONFLICTS}}"'
        msg: |
          âš ï¸  Found conflicts for {{.PACKAGE}}, backing up existing files...
    cmds:
      - echo "    No conflicts for {{.PACKAGE}}"

  restore_latest_package:
    desc: Restore the latest backup for a specific package (if it exists)
    internal: true
    vars:
      PACKAGE: '{{.PACKAGE}}'
      # Find the most recent backup containing this package (sorted newest first)
      LATEST_BACKUP:
        sh: find "{{.BACKUP_BASE}}" -mindepth 2 -maxdepth 2 -type d -name "{{.PACKAGE}}" 2>/dev/null | sort -r | head -n1 | xargs dirname 2>/dev/null | xargs basename 2>/dev/null || true
    status:
      # Skip if no backup exists for this package
      - test -z "{{.LATEST_BACKUP}}"
    cmds:
      - echo "    ðŸ“¦ Restoring backed up files for {{.PACKAGE}} from {{.LATEST_BACKUP}}..."
      - task: restore:package
        vars:
          TIMESTAMP: '{{.LATEST_BACKUP}}'
          PACKAGE: '{{.PACKAGE}}'

  restore:package:
    desc: Restore a single package from backup
    internal: true
    vars:
      TIMESTAMP: '{{.TIMESTAMP}}'
      PACKAGE: '{{.PACKAGE}}'
      PACKAGE_PATH: '{{.BACKUP_BASE}}/{{.TIMESTAMP}}/{{.PACKAGE}}'
    cmds:
      - echo "  â†’ Restoring {{.PACKAGE}}..."
      - cp -a "{{.PACKAGE_PATH}}/." "$HOME/"

  list:details:
    desc: List details for a specific backup
    internal: true
    vars:
      TIMESTAMP: '{{.TIMESTAMP}}'
      BACKUP_PATH: '{{.BACKUP_BASE}}/{{.TIMESTAMP}}'
      # Get packages in this backup
      BACKUP_PACKAGES:
        sh: find "{{.BACKUP_BASE}}/{{.TIMESTAMP}}" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | sort || true
    cmds:
      - echo "  ðŸ“… {{.TIMESTAMP}}"
      - for:
          var: BACKUP_PACKAGES
          as: PACKAGE
        task: list:package
        vars:
          TIMESTAMP: '{{.TIMESTAMP}}'
          PACKAGE: '{{.PACKAGE}}'
      - echo ""

  list:package:
    desc: List files in a specific backup package
    internal: true
    silent: true
    vars:
      TIMESTAMP: '{{.TIMESTAMP}}'
      PACKAGE: '{{.PACKAGE}}'
      FILE_COUNT:
        sh: find "{{.BACKUP_BASE}}/{{.TIMESTAMP}}/{{.PACKAGE}}" -type f | wc -l | tr -d ' '
    cmds:
      - echo "      â€¢ {{.PACKAGE}} ({{.FILE_COUNT}} files)"

  clean:old_backup:
    desc: Remove a single old backup directory
    internal: true
    vars:
      BACKUP_DIR: '{{.BACKUP_DIR}}'
    cmds:
      - echo "  Removing:" "{{.BACKUP_DIR}}"
      - rm -rf "{{.BACKUP_BASE}}/{{.BACKUP_DIR}}"

  clean:empty_backup:
    desc: Remove a single empty backup directory
    internal: true
    vars:
      BACKUP_DIR: '{{.BACKUP_DIR}}'
    cmds:
      - echo "  Removing empty:" "{{.BACKUP_DIR}}"
      - rm -rf "{{.BACKUP_BASE}}/{{.BACKUP_DIR}}"

