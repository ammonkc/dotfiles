# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: 3

silent: true

vars:
  DEV_DIR: '{{.DEV_DIR | default "$HOME/Developer"}}'
  CODE_DIR: '{{.DEV_DIR}}/code'
  REPOS_DIR: '{{.DEV_DIR}}/repos'
  # Get git username from config (empty if not found - skips creating personal dir)
  GIT_USER:
    sh: git config --get github.user 2>/dev/null | tr '[:upper:]' '[:lower:]' | tr ' ' '-' || true
  # Get work orgs from .gitconfig.*.local files (created by secrets:install:work_gitconfigs)
  WORK_ORGS:
    sh: ls ~/.gitconfig.*.local 2>/dev/null | sed 's|.*/\.gitconfig\.\(.*\)\.local|\1|' | tr '\n' ' ' | xargs || true
  DEFAULT_ORGS:
    sh: |
      if [ -n "${DEFAULT_ORGS:-}" ]; then
        echo "$DEFAULT_ORGS"
      elif grep -q '^export DEFAULT_ORGS=' ~/.env.local 2>/dev/null; then
        grep '^export DEFAULT_ORGS=' ~/.env.local | cut -d'=' -f2- | tr -d '"' | tr -d "'"
      else
        # Build from gitconfig work files + GIT_USER (if set)
        ORGS=""
        GIT_USER="{{.GIT_USER}}"
        WORK_ORGS="{{.WORK_ORGS}}"

        # Add personal org if GIT_USER is set
        if [ -n "$GIT_USER" ]; then
          ORGS="$GIT_USER"
        fi

        # Add work orgs from .gitconfig.*.local files
        if [ -n "$WORK_ORGS" ]; then
          ORGS="$ORGS $WORK_ORGS"
        fi

        # Output orgs (may be empty)
        echo "$ORGS" | xargs
      fi

tasks:
  # ============================================================================
  # Primary Tasks
  # ============================================================================

  setup:
    desc: Setup development directory structure
    summary: |
      Creates organized development directories for projects and repositories

      Structure:
        ~/Developer/
        â”œâ”€â”€ code/               # Active development projects
        â””â”€â”€ repos/              # Git repositories (organized by user/org)

      Organization directories are determined by (in order of priority):
        1. Environment variable: DEFAULT_ORGS="org1 org2 org3" task dev:setup
        2. ~/.env.local file: export DEFAULT_ORGS="org1 org2 org3"
        3. Auto-detected from:
           - Git config github.user (personal repos)
           - ~/.gitconfig.*.local files (work orgs from 1Password)
           - Skips if neither is found

      Also adds [includeIf] directives to ~/.gitconfig.local for each work org,
      so git automatically uses the correct user identity based on repo location.

      Run 'task secrets:install' first to create work gitconfig files from 1Password.

      To manually customize orgs, add to ~/.env.local:
        echo 'export DEFAULT_ORGS="myname mycompany client1"' >> ~/.env.local

      Usage: task develop:setup
    silent: true
    cmds:
      - task: create_dirs
      - task: setup:git_includes
      - echo "âœ“ Development directories created"
      - echo ""
      - echo "Directory structure:"
      - echo "  {{.CODE_DIR}}/"
      - for:
          var: DEFAULT_ORGS
        cmd: echo "  {{.REPOS_DIR}}/{{.ITEM}}/"
      - echo ""
      - 'echo "Current orgs: {{.DEFAULT_ORGS}}"'

  list:
    desc: List development directories
    summary: |
      Shows the development directory structure and repository counts
    silent: true
    cmds:
      - echo "ðŸ“‚ Development Directories:"
      - echo ""
      - task: list:code
      - task: list:repos

  clone:
    desc: Clone a repository to the appropriate directory
    summary: |
      Clones a Git repository to ~/Developer/repos/{org}/

      The organization is automatically detected from the repo URL.
      You can override it with the ORG parameter.

      Usage:
        # Auto-detect org from URL
        task dev:clone REPO=git@github.com:username/project.git
        â†’ Clones to ~/Developer/repos/username/project

        # Specify custom org
        task dev:clone REPO=https://github.com/foo/bar.git ORG=work
        â†’ Clones to ~/Developer/repos/work/bar

        # GitHub shorthand (requires gh CLI)
        task dev:clone REPO=username/repo
        â†’ Uses gh to clone from GitHub
    silent: true
    vars:
      REPO: '{{.REPO}}'
      ORG: '{{.ORG | default ""}}'
      # Detect if using GitHub shorthand format (user/repo)
      IS_GH_SHORTHAND:
        sh: echo "{{.REPO}}" | grep -qE '^[a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+$' && echo "true" || echo "false"
      # Extract org/username from repo URL or shorthand
      DETECTED_ORG:
        sh: |
          [ -n "{{.ORG}}" ] && echo "{{.ORG}}" || \
          echo "{{.REPO}}" | sed -E 's|^([^/]+)/.*|\1|; t; s|.*[:/]([^/]+)/[^/]+.*|\1|; t; s|.*|{{.GIT_USER}}|'
      # Extract repo name from URL or shorthand
      REPO_NAME:
        sh: echo "{{.REPO}}" | sed -E 's|^[^/]+/([^/]+)$|\1|; t; s|.*[:/][^/]+/([^/]+)(\.git)?$|\1|' | sed 's/\.git$//'
      TARGET_DIR: '{{.REPOS_DIR}}/{{.DETECTED_ORG}}/{{.REPO_NAME}}'
    preconditions:
      - sh: test -n "{{.REPO}}"
        msg: "REPO is required. Usage: task dev:clone REPO=<git-url-or-user/repo>"
    cmds:
      - mkdir -p "{{.REPOS_DIR}}/{{.DETECTED_ORG}}"
      - echo "ðŸ“¥ Cloning {{.REPO_NAME}} to {{.DETECTED_ORG}}/"
      - |
        if [ "{{.IS_GH_SHORTHAND}}" = "true" ]; then
          # Use gh CLI for GitHub shorthand
          if command -v gh >/dev/null 2>&1; then
            gh repo clone "{{.REPO}}" "{{.TARGET_DIR}}"
          else
            echo "Error: gh CLI not found. Install with: brew install gh"
            exit 1
          fi
        else
          git clone "{{.REPO}}" "{{.TARGET_DIR}}"
        fi
      - echo "âœ“ Cloned to:" "{{.TARGET_DIR}}"
    status:
      - test -d "{{.TARGET_DIR}}"

  # ============================================================================
  # Placeholder Tasks (Future Development)
  # ============================================================================

  sync:
    desc: Sync all repositories (placeholder)
    summary: |
      Future: Sync all repos in ~/Developer/repos/
      Could pull latest changes, check for updates, etc.
    cmds:
      - echo "ðŸš§ Not implemented yet"
      - echo "This will sync all repositories in {{.REPOS_DIR}}/"

  update:
    desc: Update all repositories (placeholder)
    summary: |
      Future: Update all repos (pull, fetch, etc.)
    cmds:
      - echo "ðŸš§ Not implemented yet"
      - echo "This will update all repositories"

  status:
    desc: Show git status for all repositories (placeholder)
    summary: |
      Future: Show git status for all repos
    cmds:
      - echo "ðŸš§ Not implemented yet"
      - echo "This will show status of all repositories"

  # ============================================================================
  # Internal Tasks
  # ============================================================================

  create_dirs:
    internal: true
    cmds:
      - mkdir -p "{{.CODE_DIR}}"
      - for:
          var: DEFAULT_ORGS
        cmd: mkdir -p "{{.REPOS_DIR}}/{{.ITEM}}"
    status:
      - test -d "{{.CODE_DIR}}"

  setup:git_includes:
    desc: Add includeIf directives to gitconfig.local for work orgs
    internal: true
    silent: true
    vars:
      GITCONFIG_LOCAL: '$HOME/.gitconfig.local'
    cmds:
      - |
        set -e  # Exit on first error

        # Add includeIf directives for each work org's gitconfig
        for ORG in {{.WORK_ORGS}}; do
          GITCONFIG_ORG="$HOME/.gitconfig.${ORG}.local"
          INCLUDE_PATTERN="[includeIf \"gitdir:{{.REPOS_DIR}}/${ORG}/\"]"

          # Skip if org gitconfig doesn't exist
          if [ ! -f "$GITCONFIG_ORG" ]; then
            continue
          fi

          # Skip if includeIf already exists (check for both / and /** patterns)
          if grep -qE "gitdir:{{.REPOS_DIR}}/${ORG}/(\*\*)?" "{{.GITCONFIG_LOCAL}}" 2>/dev/null; then
            echo "  â†’ includeIf for ${ORG} already configured"
            continue
          fi

          # Append includeIf directive (** matches all subdirectories)
          {
            echo ""
            echo "[includeIf \"gitdir:{{.REPOS_DIR}}/${ORG}/**\"]"
            echo "  path = ~/.gitconfig.${ORG}.local"
          } >> "{{.GITCONFIG_LOCAL}}"

          echo "âœ“ Added includeIf for ${ORG} repos"
        done

  list:code:
    internal: true
    silent: true
    vars:
      CODE_PROJECTS:
        sh: find "{{.CODE_DIR}}" -mindepth 1 -maxdepth 1 -exec basename {} \; 2>/dev/null | sort || true
      PROJECT_COUNT:
        sh: find "{{.CODE_DIR}}" -mindepth 1 -maxdepth 1 2>/dev/null | wc -l | xargs || echo "0"
    preconditions:
      - sh: test -d "{{.CODE_DIR}}"
        msg: ""
    cmds:
      - echo "Code projects ({{.CODE_DIR}}):"
      - |
        if [ "{{.PROJECT_COUNT}}" -eq 0 ]; then
          echo "  (empty)"
        fi
      - for:
          var: CODE_PROJECTS
          split: '\n'
        cmd: echo "  - {{.ITEM}}"
      - echo ""

  list:repos:
    internal: true
    silent: true
    vars:
      ORGS:
        sh: find "{{.REPOS_DIR}}" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | sort || true
      ORG_COUNT:
        sh: find "{{.REPOS_DIR}}" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l | xargs || echo "0"
    preconditions:
      - sh: test -d "{{.REPOS_DIR}}"
        msg: ""
    cmds:
      - echo "Repositories:"
      - |
        if [ "{{.ORG_COUNT}}" -eq 0 ]; then
          echo "  (no organizations)"
        fi
      - for:
          var: ORGS
          split: '\n'
        task: list:org
        vars:
          ORG_NAME: '{{.ITEM}}'

  list:org:
    internal: true
    silent: true
    vars:
      ORG_NAME: '{{.ORG_NAME}}'
      ORG_PATH: '{{.REPOS_DIR}}/{{.ORG_NAME}}'
      REPOS:
        sh: find "{{.ORG_PATH}}" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | sort || true
      REPO_COUNT:
        sh: find "{{.ORG_PATH}}" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l | xargs || echo "0"
    cmds:
      - echo "  {{.ORG_NAME}}/ ({{.REPO_COUNT}} repos)"
      - for:
          var: REPOS
          split: '\n'
        task: list:repo
        vars:
          REPO_NAME: '{{.ITEM}}'

  list:repo:
    internal: true
    silent: true
    vars:
      REPO_NAME: '{{.REPO_NAME}}'
    cmds:
      - echo "    - {{.REPO_NAME}}"

