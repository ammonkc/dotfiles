# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: 3

silent: true

includes:
  github:
    taskfile: ./github.yml
    internal: true

vars:
  HOME: '{{env "HOME"}}'
  # Default 1Password account (can be overridden via OP_ACCOUNT env var)
  OP_ACCOUNT: '{{env "OP_ACCOUNT" | default "my.1password.com"}}'
  GITCONFIG_LOCAL: '{{.HOME}}/.gitconfig.local'
  ENV_LOCAL: '{{.HOME}}/.env.local'
  SSH_CONFIG_LOCAL: '{{.HOME}}/.ssh/config'
  SECRETS_MARKER: "# --- 1Password secrets (do not edit below) ---"

tasks:
  # ============================================================================
  # Primary Tasks
  # ============================================================================

  install:
    desc: Install local secrets from 1Password
    summary: |
      Retrieves secrets from 1Password and appends to local config files:
      - ~/.gitconfig.local (git/github credentials from personal account)
      - ~/.env.local (environment variables)
      - ~/.ssh/config (SSH host configurations)
      - ~/.gitconfig.<work>.local (user info for each business account)
      - GitHub SSH keys (synced via gh CLI if available)

      Skips files that already have secrets installed.
      Requires 1Password CLI to be installed and authenticated.
      GitHub key sync requires gh CLI (optional, skipped if not available).
    platforms: [darwin]
    preconditions:
      - sh: command -v op >/dev/null 2>&1
        msg: |
          1Password CLI is not installed.
          Run: brew install --cask 1password-cli
      - sh: command -v jq >/dev/null 2>&1
        msg: |
          jq is not installed.
          Run: brew install jq
      - sh: op account list >/dev/null 2>&1
        msg: |
          Not signed in to 1Password CLI.
          Run: op signin
    cmds:
      - task: install:personal
      - task: install:work

  # ============================================================================
  # Personal Account Secrets (primary 1Password account)
  # ============================================================================

  install:personal:
    desc: Install secrets from personal 1Password account
    internal: true
    silent: true
    platforms: [darwin]
    cmds:
      - task: install:personal:gitconfig
      - task: install:personal:env
      - task: install:personal:ssh
      - task: install:personal:github-keys
      # Future personal secrets can be added here:
      # - task: install:personal:npm
      # - task: install:personal:aws

  install:personal:gitconfig:
    desc: Add [user] and [github] sections to ~/.gitconfig.local from 1Password
    internal: true
    silent: true
    platforms: [darwin]
    status:
      - grep -qF "{{.SECRETS_MARKER}}" "{{.GITCONFIG_LOCAL}}" 2>/dev/null
    cmds:
      - |
        # Get user info from 1Password account (required)
        USER_INFO=$(op user get --me --account "{{.OP_ACCOUNT}}" --format=json) || {
          echo "âŒ Failed to get user info from 1Password"
          exit 1
        }
        USER_EMAIL=$(echo "$USER_INFO" | jq -r '.email')
        USER_NAME=$(echo "$USER_INFO" | jq -r '.name')

        # Get signing key (optional)
        SIGNING_KEY=$(op item get "id_ed25519" --account "{{.OP_ACCOUNT}}" --fields label="public key" 2>/dev/null) || true

        # Get GitHub credentials (optional)
        GH_USER=$(op item get "github" --account "{{.OP_ACCOUNT}}" --fields label=username 2>/dev/null) || true
        GH_TOKEN=$(op item get "github" --account "{{.OP_ACCOUNT}}" --fields label=token 2>/dev/null) || true

        # Append to gitconfig.local
        {
          echo ""
          echo "{{.SECRETS_MARKER}}"
          echo "[user]"
          echo "  name = ${USER_NAME}"
          echo "  email = ${USER_EMAIL}"
          if [ -n "$SIGNING_KEY" ]; then
            echo "  signingkey = ${SIGNING_KEY}"
          fi
          if [ -n "$GH_USER" ] || [ -n "$GH_TOKEN" ]; then
            echo ""
            echo "[github]"
            if [ -n "$GH_USER" ]; then echo "  user = ${GH_USER}"; fi
            if [ -n "$GH_TOKEN" ]; then echo "  token = ${GH_TOKEN}"; fi
          fi
        } >> "{{.GITCONFIG_LOCAL}}"
      - |
        # Append additional config from 1Password document if it exists
        if op document get ".gitconfig.local" --account "{{.OP_ACCOUNT}}" >/dev/null 2>&1; then
          echo "" >> "{{.GITCONFIG_LOCAL}}"
          op document get ".gitconfig.local" --account "{{.OP_ACCOUNT}}" >> "{{.GITCONFIG_LOCAL}}"
        fi
        true  # Ensure exit 0 even if document doesn't exist
      - echo "âœ“ Added secrets from 1Password to {{.GITCONFIG_LOCAL}}"

  install:personal:env:
    desc: Append 1Password secrets to ~/.env.local
    internal: true
    silent: true
    platforms: [darwin]
    status:
      - grep -qF "{{.SECRETS_MARKER}}" "{{.ENV_LOCAL}}" 2>/dev/null
    cmds:
      - |
        # Add OP_ACCOUNT if not already present
        if ! grep -qF "OP_ACCOUNT=" "{{.ENV_LOCAL}}" 2>/dev/null; then
          echo "" >> "{{.ENV_LOCAL}}"
          echo "# Personal 1Password account for automation scripts" >> "{{.ENV_LOCAL}}"
          echo "export OP_ACCOUNT=\"{{.OP_ACCOUNT}}\"" >> "{{.ENV_LOCAL}}"
          echo "âœ“ Added OP_ACCOUNT to {{.ENV_LOCAL}}"
        fi
      - |
        # Append env secrets from 1Password document if it exists
        if op document get ".env.local" --account "{{.OP_ACCOUNT}}" >/dev/null 2>&1; then
          echo "" >> "{{.ENV_LOCAL}}"
          echo "{{.SECRETS_MARKER}}" >> "{{.ENV_LOCAL}}"
          op document get ".env.local" --account "{{.OP_ACCOUNT}}" >> "{{.ENV_LOCAL}}"
          echo "âœ“ Added secrets from 1Password to {{.ENV_LOCAL}}"
        else
          echo "  â†’ No .env.local document found in 1Password, skipping"
        fi

  install:personal:ssh:
    desc: Append 1Password secrets to ~/.ssh/config
    internal: true
    silent: true
    platforms: [darwin]
    status:
      - grep -qF "{{.SECRETS_MARKER}}" "{{.SSH_CONFIG_LOCAL}}" 2>/dev/null
    cmds:
      - |
        # Add GitHub host config if not already present and github item exists
        if grep -qF "Host *.github.com" "{{.SSH_CONFIG_LOCAL}}" 2>/dev/null; then
          echo "  â†’ GitHub host already configured in SSH config"
        else
          # Get GitHub username from 1Password (optional)
          GH_USERNAME=$(op item get "github" --account "{{.OP_ACCOUNT}}" --fields label=username 2>/dev/null) || true

          if [ -n "$GH_USERNAME" ]; then
            # Prepend GitHub host to existing config (using temp file to avoid truncation)
            TMPFILE=$(mktemp)
            echo "Host *.github.com" > "$TMPFILE"
            echo "  User ${GH_USERNAME}" >> "$TMPFILE"
            echo "" >> "$TMPFILE"
            # Append existing config if file exists
            if [ -f "{{.SSH_CONFIG_LOCAL}}" ]; then
              cat "{{.SSH_CONFIG_LOCAL}}" >> "$TMPFILE"
            fi
            mv "$TMPFILE" "{{.SSH_CONFIG_LOCAL}}"
            echo "  âœ“ Added GitHub host to SSH config"
          else
            echo "  â†’ No github item in 1Password, skipping GitHub host config"
          fi
        fi
      - |
        # Append SSH config secrets from 1Password document if it exists
        if op document get "ssh_config.local" --account "{{.OP_ACCOUNT}}" >/dev/null 2>&1; then
          echo "" >> "{{.SSH_CONFIG_LOCAL}}"
          echo "{{.SECRETS_MARKER}}" >> "{{.SSH_CONFIG_LOCAL}}"
          op document get "ssh_config.local" --account "{{.OP_ACCOUNT}}" >> "{{.SSH_CONFIG_LOCAL}}"
          echo "âœ“ Added SSH secrets from 1Password to {{.SSH_CONFIG_LOCAL}}"
        else
          echo "  â†’ No ssh_config.local document in 1Password, skipping"
        fi
      - |
        # Ensure proper permissions if file exists
        if [ -f "{{.SSH_CONFIG_LOCAL}}" ]; then
          chmod 600 "{{.SSH_CONFIG_LOCAL}}"
        fi

  install:personal:github-keys:
    desc: Sync SSH keys from 1Password to GitHub
    internal: true
    silent: true
    platforms: [darwin]
    cmds:
      - |
        # Check gh CLI prerequisites - exit gracefully if not met (optional feature)
        if ! command -v gh >/dev/null 2>&1; then
          echo "  â†’ gh CLI not installed, skipping GitHub key sync"
          exit 0
        fi
        if ! gh auth status >/dev/null 2>&1; then
          echo "  â†’ gh CLI not authenticated, skipping GitHub key sync"
          echo "    Run: gh auth login"
          exit 0
        fi
        # Delegate to github task - it handles 1Password errors gracefully
        task github:keys:add OP_ITEM="id_ed25519" OP_ACCOUNT="{{.OP_ACCOUNT}}" TITLE="1Password id_ed25519" 2>/dev/null || {
          echo "  â†’ No id_ed25519 item in 1Password or sync failed"
        }

  # ============================================================================
  # Work Account Secrets (business 1Password accounts)
  # ============================================================================

  install:work:
    desc: Install secrets from business 1Password accounts
    internal: true
    silent: true
    platforms: [darwin]
    vars:
      # Discover work accounts once, pass to all subtasks
      WORK_ACCOUNTS:
        sh: op account list --format=json 2>/dev/null | jq -r '.[] | select(.url != "{{.OP_ACCOUNT}}") | .url' || true
    cmds:
      - |
        if [ -z "{{.WORK_ACCOUNTS}}" ]; then
          echo "âš  No business 1Password accounts found, skipping work secrets"
          exit 0
        fi
      - task: install:work:gitconfigs
        vars:
          WORK_ACCOUNTS: "{{.WORK_ACCOUNTS}}"
      - task: install:work:env
        vars:
          WORK_ACCOUNTS: "{{.WORK_ACCOUNTS}}"
      - task: install:work:github-keys
        vars:
          WORK_ACCOUNTS: "{{.WORK_ACCOUNTS}}"
      # Future work secrets can be added here:
      # - task: install:work:aws
      #   vars:
      #     WORK_ACCOUNTS: "{{.WORK_ACCOUNTS}}"

  install:work:gitconfigs:
    desc: Create gitconfig files for business 1Password accounts
    internal: true
    silent: true
    platforms: [darwin]
    requires:
      vars: [WORK_ACCOUNTS]
    cmds:
      - |
        SUCCESS=0
        SKIPPED=0
        FAILED=0

        for ACCOUNT in {{.WORK_ACCOUNTS}}; do
          # Get user info from business account (may fail if not signed in)
          USER_INFO=$(op user get --me --account "$ACCOUNT" --format=json 2>/dev/null) || {
            echo "  â†’ Skipping $ACCOUNT (not signed in or unavailable)"
            SKIPPED=$((SKIPPED + 1))
            continue
          }
          USER_EMAIL=$(echo "$USER_INFO" | jq -r '.email')
          USER_NAME=$(echo "$USER_INFO" | jq -r '.name')

          # Extract work name from email domain (e.g., "ammon@mywork.com" -> "mywork")
          WORK_NAME=$(echo "$USER_EMAIL" | sed 's/.*@//' | sed 's/\..*//')
          GITCONFIG_FILE="{{.HOME}}/.gitconfig.${WORK_NAME}.local"

          # Skip if file already has secrets marker
          if grep -qF "{{.SECRETS_MARKER}}" "$GITCONFIG_FILE" 2>/dev/null; then
            echo "  â†’ $GITCONFIG_FILE already configured"
            SKIPPED=$((SKIPPED + 1))
            continue
          fi

          # Get signing key from work account (optional)
          SIGNING_KEY=$(op item get "id_ed25519" --account "$ACCOUNT" --fields label="public key" 2>/dev/null) || true

          # Create gitconfig file
          {
            echo "# Work gitconfig for ${WORK_NAME}"
            echo "{{.SECRETS_MARKER}}"
            echo "[user]"
            echo "  name = ${USER_NAME}"
            echo "  email = ${USER_EMAIL}"
            if [ -n "$SIGNING_KEY" ]; then
              echo "  signingkey = ${SIGNING_KEY}"
            fi
          } > "$GITCONFIG_FILE" && {
            echo "âœ“ Created $GITCONFIG_FILE"
            SUCCESS=$((SUCCESS + 1))
          } || {
            echo "âŒ Failed to create $GITCONFIG_FILE"
            FAILED=$((FAILED + 1))
          }
        done

        # Summary (only show if there were multiple accounts)
        TOTAL=$((SUCCESS + SKIPPED + FAILED))
        if [ $TOTAL -gt 1 ]; then
          echo ""
          echo "  Summary: $SUCCESS created, $SKIPPED skipped, $FAILED failed"
        fi

  install:work:env:
    desc: Add work 1Password account to ~/.env.local
    internal: true
    silent: true
    platforms: [darwin]
    requires:
      vars: [WORK_ACCOUNTS]
    status:
      - grep -qF "OP_WORK_ACCOUNT=" "{{.ENV_LOCAL}}" 2>/dev/null
    cmds:
      - |
        # Find first account we can access
        WORK_ACCOUNT=""
        for ACCOUNT in {{.WORK_ACCOUNTS}}; do
          if op user get --me --account "$ACCOUNT" >/dev/null 2>&1; then
            WORK_ACCOUNT="$ACCOUNT"
            break
          fi
        done

        if [ -z "$WORK_ACCOUNT" ]; then
          echo "âš  No accessible work accounts, skipping OP_WORK_ACCOUNT"
          exit 0
        fi

        # Add to ~/.env.local
        echo "" >> "{{.ENV_LOCAL}}"
        echo "# Work 1Password account for automation scripts" >> "{{.ENV_LOCAL}}"
        echo "export OP_WORK_ACCOUNT=\"${WORK_ACCOUNT}\"" >> "{{.ENV_LOCAL}}"
        echo "âœ“ Added OP_WORK_ACCOUNT to {{.ENV_LOCAL}}"

  install:work:github-keys:
    desc: Sync SSH keys from work 1Password accounts to GitHub
    internal: true
    silent: true
    platforms: [darwin]
    requires:
      vars: [WORK_ACCOUNTS]
    cmds:
      - |
        # Check if gh CLI is available (graceful skip for optional feature)
        if ! command -v gh >/dev/null 2>&1; then
          echo "  â†’ gh CLI not installed, skipping work GitHub key sync"
          exit 0
        fi
        if ! gh auth status >/dev/null 2>&1; then
          echo "  â†’ gh CLI not authenticated, skipping work GitHub key sync"
          exit 0
        fi

        SUCCESS=0
        SKIPPED=0
        FAILED=0

        for ACCOUNT in {{.WORK_ACCOUNTS}}; do
          # Get user info to determine work name
          USER_INFO=$(op user get --me --account "$ACCOUNT" --format=json 2>/dev/null) || {
            echo "  â†’ Skipping $ACCOUNT (not signed in)"
            SKIPPED=$((SKIPPED + 1))
            continue
          }
          USER_EMAIL=$(echo "$USER_INFO" | jq -r '.email')
          WORK_NAME=$(echo "$USER_EMAIL" | sed 's/.*@//' | sed 's/\..*//')

          # Check if 1Password has the key before calling github task
          if ! op item get "id_ed25519" --account "$ACCOUNT" --fields label="public key" >/dev/null 2>&1; then
            echo "  â†’ No id_ed25519 in $WORK_NAME 1Password"
            SKIPPED=$((SKIPPED + 1))
            continue
          fi

          # Delegate to github:keys:add task
          if task github:keys:add OP_ITEM="id_ed25519" OP_ACCOUNT="$ACCOUNT" TITLE="1Password ${WORK_NAME} id_ed25519" 2>/dev/null; then
            SUCCESS=$((SUCCESS + 1))
          else
            FAILED=$((FAILED + 1))
          fi
        done

        # Summary (only show if there were multiple accounts)
        TOTAL=$((SUCCESS + SKIPPED + FAILED))
        if [ $TOTAL -gt 1 ]; then
          echo ""
          echo "  Summary: $SUCCESS synced, $SKIPPED skipped, $FAILED failed"
        fi

  status:
    desc: Show status of installed secrets
    summary: |
      Shows which secret files have been configured with 1Password data.
    platforms: [darwin]
    silent: true
    cmds:
      - echo "ðŸ” Secrets Status:"
      - echo ""
      - |
        if grep -qF "{{.SECRETS_MARKER}}" "{{.GITCONFIG_LOCAL}}" 2>/dev/null; then
          echo "  âœ“ {{.GITCONFIG_LOCAL}}"
        else
          echo "  âœ— {{.GITCONFIG_LOCAL}} (not configured)"
        fi
      - |
        if grep -qF "{{.SECRETS_MARKER}}" "{{.ENV_LOCAL}}" 2>/dev/null; then
          echo "  âœ“ {{.ENV_LOCAL}}"
        else
          echo "  âœ— {{.ENV_LOCAL}} (not configured)"
        fi
      - |
        if grep -qF "{{.SECRETS_MARKER}}" "{{.SSH_CONFIG_LOCAL}}" 2>/dev/null; then
          echo "  âœ“ {{.SSH_CONFIG_LOCAL}}"
        else
          echo "  âœ— {{.SSH_CONFIG_LOCAL}} (not configured)"
        fi
      - echo ""
      - echo "Work gitconfigs:"
      - |
        for f in ~/.gitconfig.*.local; do
          [ -f "$f" ] || continue
          # Skip the main .gitconfig.local
          [ "$f" = "$HOME/.gitconfig.local" ] && continue
          ORG=$(echo "$f" | sed 's|.*/\.gitconfig\.\(.*\)\.local|\1|')
          if grep -qF "{{.SECRETS_MARKER}}" "$f" 2>/dev/null; then
            echo "  âœ“ ~/.gitconfig.${ORG}.local"
          else
            echo "  âœ— ~/.gitconfig.${ORG}.local (not from 1Password)"
          fi
        done

  refresh:
    desc: Force refresh all secrets from 1Password
    summary: |
      Removes existing 1Password secrets section and re-downloads from 1Password.
      Use this if your 1Password secrets have been updated.

      Note: Only removes the "# --- 1Password secrets" section, preserves other content.
    platforms: [darwin]
    silent: true
    preconditions:
      - sh: command -v op >/dev/null 2>&1
        msg: |
          1Password CLI is not installed.
          Run: brew install --cask 1password-cli
      - sh: op account list >/dev/null 2>&1
        msg: |
          Not signed in to 1Password CLI.
          Run: op signin
    cmds:
      - echo "ðŸ”„ Refreshing secrets from 1Password..."
      # Remove existing 1Password sections (everything from marker to end of file)
      - |
        if grep -qF "{{.SECRETS_MARKER}}" "{{.GITCONFIG_LOCAL}}" 2>/dev/null; then
          sed -i '' '/{{.SECRETS_MARKER}}/,$d' "{{.GITCONFIG_LOCAL}}"
          echo "  â†’ Removed old secrets from {{.GITCONFIG_LOCAL}}"
        fi
        true  # Ensure exit 0
      - |
        if grep -qF "{{.SECRETS_MARKER}}" "{{.ENV_LOCAL}}" 2>/dev/null; then
          sed -i '' '/{{.SECRETS_MARKER}}/,$d' "{{.ENV_LOCAL}}"
          echo "  â†’ Removed old secrets from {{.ENV_LOCAL}}"
        fi
        true  # Ensure exit 0
      - |
        if grep -qF "{{.SECRETS_MARKER}}" "{{.SSH_CONFIG_LOCAL}}" 2>/dev/null; then
          sed -i '' '/{{.SECRETS_MARKER}}/,$d' "{{.SSH_CONFIG_LOCAL}}"
          echo "  â†’ Removed old secrets from {{.SSH_CONFIG_LOCAL}}"
        fi
        true  # Ensure exit 0
      - task: install
      - echo "âœ“ All secrets refreshed"

  refresh:github:token:
    desc: Update GitHub token in ~/.gitconfig.local from 1Password
    aliases: [gh-token]
    summary: |
      Fetches the current GitHub token from 1Password and updates it in ~/.gitconfig.local

      Use this when your GitHub PAT has expired or been rotated.
    platforms: [darwin]
    silent: true
    preconditions:
      - sh: command -v op >/dev/null 2>&1
        msg: |
          1Password CLI is not installed.
          Run: brew install --cask 1password-cli
      - sh: op account list >/dev/null 2>&1
        msg: |
          Not signed in to 1Password CLI.
          Run: op signin
      - sh: grep -qF "[github]" "{{.GITCONFIG_LOCAL}}" 2>/dev/null
        msg: |
          No [github] section found in {{.GITCONFIG_LOCAL}}
          Run 'task secrets:install' first to set up initial config.
    cmds:
      - |
        # Get current token from 1Password
        NEW_TOKEN=$(op item get "github" --account "{{.OP_ACCOUNT}}" --fields label=token 2>/dev/null) || {
          echo "âŒ Failed to get GitHub token from 1Password"
          echo "   Make sure you have a 'github' item with a 'token' field"
          exit 1
        }

        if [ -z "$NEW_TOKEN" ]; then
          echo "âŒ GitHub token is empty in 1Password"
          exit 1
        fi

        # Check if token line exists and update it
        if grep -qE "^\s*token\s*=" "{{.GITCONFIG_LOCAL}}"; then
          # Update existing token in-place
          sed -i '' "s|^\([[:space:]]*token[[:space:]]*=[[:space:]]*\).*|\1${NEW_TOKEN}|" "{{.GITCONFIG_LOCAL}}"
          echo "âœ“ Updated GitHub token in {{.GITCONFIG_LOCAL}}"
        else
          # Token line doesn't exist, add it after [github] section using awk
          awk -v token="$NEW_TOKEN" '/\[github\]/{print; print "  token = " token; next}1' "{{.GITCONFIG_LOCAL}}" > "{{.GITCONFIG_LOCAL}}.tmp" \
            && mv "{{.GITCONFIG_LOCAL}}.tmp" "{{.GITCONFIG_LOCAL}}"
          echo "âœ“ Added GitHub token to {{.GITCONFIG_LOCAL}}"
        fi

  sync:github-keys:
    desc: Sync SSH keys from 1Password to GitHub
    aliases: [gh-keys]
    summary: |
      Fetches SSH keys from 1Password and ensures they are registered in GitHub.

      Adds keys for both authentication and signing if not already present.
      Requires:
        - 1Password CLI (op) installed and signed in
        - GitHub CLI (gh) installed and authenticated
        - An "id_ed25519" item in 1Password with a "public key" field

      Note: This delegates to github:keys:add for the actual GitHub interaction.
    platforms: [darwin]
    silent: true
    preconditions:
      - sh: command -v op >/dev/null 2>&1
        msg: |
          1Password CLI is not installed.
          Run: brew install --cask 1password-cli
      - sh: op account list >/dev/null 2>&1
        msg: |
          Not signed in to 1Password CLI.
          Run: op signin
      - sh: command -v gh >/dev/null 2>&1
        msg: |
          GitHub CLI is not installed.
          Run: brew install gh
      - sh: gh auth status >/dev/null 2>&1
        msg: |
          GitHub CLI is not authenticated.
          Run: gh auth login
    cmds:
      - echo "ðŸ”„ Syncing SSH keys from 1Password to GitHub..."
      - task: github:keys:add
        vars:
          OP_ITEM: id_ed25519
          OP_ACCOUNT: '{{.OP_ACCOUNT}}'
          TITLE: '1Password id_ed25519'
      - echo ""
      - echo "Done! Your GitHub SSH keys are synced."

  sync:work:github-keys:
    desc: Sync SSH keys from work 1Password accounts to GitHub
    aliases: [work-keys]
    summary: |
      Fetches SSH keys from work 1Password accounts and ensures they are registered in GitHub.

      Adds keys for both authentication and signing if not already present.
      Iterates through all business 1Password accounts.

      Requires:
        - 1Password CLI (op) installed and signed in to work accounts
        - GitHub CLI (gh) installed and authenticated
        - An "id_ed25519" item in each work 1Password account

      Note: This delegates to github:keys:add for the actual GitHub interaction.
    platforms: [darwin]
    silent: true
    vars:
      WORK_ACCOUNTS:
        sh: op account list --format=json 2>/dev/null | jq -r '.[] | select(.url != "{{.OP_ACCOUNT}}") | .url' || true
    preconditions:
      - sh: command -v op >/dev/null 2>&1
        msg: |
          1Password CLI is not installed.
          Run: brew install --cask 1password-cli
      - sh: command -v jq >/dev/null 2>&1
        msg: |
          jq is not installed.
          Run: brew install jq
      - sh: op account list >/dev/null 2>&1
        msg: |
          Not signed in to 1Password CLI.
          Run: op signin
      - sh: command -v gh >/dev/null 2>&1
        msg: |
          GitHub CLI is not installed.
          Run: brew install gh
      - sh: gh auth status >/dev/null 2>&1
        msg: |
          GitHub CLI is not authenticated.
          Run: gh auth login
    cmds:
      - echo "ðŸ”„ Syncing work SSH keys from 1Password to GitHub..."
      - |
        if [ -z "{{.WORK_ACCOUNTS}}" ]; then
          echo "âš  No business 1Password accounts found"
          exit 0
        fi
      - |
        SUCCESS=0
        SKIPPED=0
        FAILED=0

        for ACCOUNT in {{.WORK_ACCOUNTS}}; do
          # Get user info to determine work name
          USER_INFO=$(op user get --me --account "$ACCOUNT" --format=json 2>/dev/null) || {
            echo ""
            echo "âš  Skipping $ACCOUNT (not signed in)"
            SKIPPED=$((SKIPPED + 1))
            continue
          }
          USER_EMAIL=$(echo "$USER_INFO" | jq -r '.email')
          WORK_NAME=$(echo "$USER_EMAIL" | sed 's/.*@//' | sed 's/\..*//')

          echo ""
          echo "ðŸ“¦ ${WORK_NAME} (${ACCOUNT})"

          # Check if 1Password has the key before calling github task
          if ! op item get "id_ed25519" --account "$ACCOUNT" --fields label="public key" >/dev/null 2>&1; then
            echo "   â†’ No id_ed25519 item found"
            SKIPPED=$((SKIPPED + 1))
            continue
          fi

          # Delegate to github:keys:add task
          if task github:keys:add OP_ITEM="id_ed25519" OP_ACCOUNT="$ACCOUNT" TITLE="1Password ${WORK_NAME} id_ed25519" 2>/dev/null; then
            SUCCESS=$((SUCCESS + 1))
          else
            FAILED=$((FAILED + 1))
          fi
        done

        echo ""
        echo "Summary: $SUCCESS synced, $SKIPPED skipped, $FAILED failed"
      - echo ""
      - echo "Done! Work GitHub SSH keys are synced."

  sync:all-keys:
    desc: Sync all SSH keys (personal + work) to GitHub
    aliases: [all-keys]
    summary: |
      Syncs SSH keys from both personal and work 1Password accounts to GitHub.

      This combines sync:github-keys (personal) and sync:work:github-keys (work).
      For more control, run those tasks individually.

      Requires:
        - 1Password CLI (op) installed and signed in
        - GitHub CLI (gh) installed and authenticated
    platforms: [darwin]
    silent: true
    cmds:
      - task: sync:github-keys
      - task: sync:work:github-keys
